<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="간단 요약
행렬을 인수분해 후 재생성하여 결측치를 예측하는 방법
인수분해를 다양하게 시도하여 대상 행렬을 가장 잘 복구하는 최적의 하위행렬을 찾는 과정 {: .prompt-info } Latent Factors, Matrix Factorization, SGD
행렬을 인수분해 후 재생성하여 결측치를 예측하는 방법
대상 행렬을 두개의 하위 행렬로 분해한다.
User-Item 행렬을 User와 Item 각각에 대한 저차원의 latent factor 행렬로 분해한다.
두 하위 행렬을 다시 곱해서 대상 행렬과 동일한 크기의 단일 행렬로 만든다.
위의 과정에서 기존 행렬의 빈공간이 채워진다.">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="MF: Matrix Factorization" />
<meta property="og:description" content="간단 요약
행렬을 인수분해 후 재생성하여 결측치를 예측하는 방법
인수분해를 다양하게 시도하여 대상 행렬을 가장 잘 복구하는 최적의 하위행렬을 찾는 과정 {: .prompt-info } Latent Factors, Matrix Factorization, SGD
행렬을 인수분해 후 재생성하여 결측치를 예측하는 방법
대상 행렬을 두개의 하위 행렬로 분해한다.
User-Item 행렬을 User와 Item 각각에 대한 저차원의 latent factor 행렬로 분해한다.
두 하위 행렬을 다시 곱해서 대상 행렬과 동일한 크기의 단일 행렬로 만든다.
위의 과정에서 기존 행렬의 빈공간이 채워진다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://osmin625.github.io/posts/2023-05-14-MF-Matrix-Factorization/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-03-30T12:19:00+09:00" />
<meta property="article:modified_time" content="2024-01-10T01:07:46+09:00" />

<title>MF: Matrix Factorization | OMIN</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="stylesheet" href="/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css" integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz&#43;OQteg=" crossorigin="anonymous"><!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>OMIN</span>
  </a>
</h2>













  












  
<ul>
  
  <li>
    <a href="/posts/"  >
        Blog
      </a>
  </li>
  
  <li>
    <a href="https://github.com/osmin625/"  target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
    <label for="menu-control">
      <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
    </label>
  
    <strong>MF: Matrix Factorization</strong>
  
    <label for="toc-control">
      
      <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
      
    </label>
  </div>
  

  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#모델-학습-과정">모델 학습 과정</a></li>
        <li><a href="#objective-function">Objective Function</a>
          <ul>
            <li><a href="#기본-형태">기본 형태</a></li>
            <li><a href="#최종-형태">최종 형태</a></li>
            <li><a href="#mf-학습">MF 학습</a></li>
          </ul>
        </li>
        <li><a href="#mf-기반-추천으로-가장-널리-알려진-논문">MF 기반 추천으로 가장 널리 알려진 논문</a>
          <ul>
            <li><a href="#adding-biases">Adding Biases</a></li>
            <li><a href="#adding-confidence-level">Adding Confidence Level</a></li>
            <li><a href="#adding-temporal-dynamics">Adding Temporal Dynamics</a></li>
          </ul>
        </li>
        <li><a href="#단점">단점</a></li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown book-post">
  <h1>
    <a href="/posts/2023-05-14-MF-Matrix-Factorization/">MF: Matrix Factorization</a>
  </h1>
  
  <h5>March 30, 2023</h5>



  
  <div>
    
      <a href="/categories/DL-Algorithm/">DL Algorithm</a>, 
      <a href="/categories/Recommendation-System/">Recommendation System</a>
  </div>
  

  
  <div>
    
      <a href="/tags/Collaborative-Filtering/">Collaborative Filtering</a>, 
      <a href="/tags/matrix-factorization/">matrix factorization</a>
  </div>
  



<blockquote>
<p>간단 요약</p>
<p>행렬을 인수분해 후 재생성하여 결측치를 예측하는 방법</p>
<p>인수분해를 다양하게 시도하여 대상 행렬을 가장 잘 복구하는 최적의 하위행렬을 찾는 과정
{: .prompt-info }
Latent Factors, Matrix Factorization, SGD</p>
</blockquote>
<p><strong>행렬을 인수분해 후 재생성하여 결측치를 예측하는 방법</strong></p>
<ol>
<li>
<p>대상 행렬을 두개의 하위 행렬로 분해한다.</p>
<p>User-Item 행렬을 User와 Item 각각에 대한 저차원의 latent factor 행렬로 분해한다.</p>
</li>
<li>
<p>두 하위 행렬을 다시 곱해서 대상 행렬과 동일한 크기의 단일 행렬로 만든다.</p>
</li>
<li>
<p><strong>위의 과정에서 기존 행렬의 빈공간이 채워진다.</strong></p>
<p>이는 행렬의 성질을 이용한 것이다.</p>
<p>즉, 결측값(비평가 항목)에 대해 임의로 Imputation을 수행하지 않는다.</p>
<p>실제로 관측된 값만 활용한다.</p>
</li>
</ol>
<p>요약하면, 인수분해를 다양하게 시도하여 대상 행렬을 가장 잘 복구하는 최적의 하위행렬을 찾는 과정이다.</p>
<p>기계가 해석하기 위한 행렬, 즉 블랙 박스 모델에 더 가깝다.</p>
<p>추천시스템에서 두 개의 하위행렬은 각각 유저 임베딩(User Latent Factors)과 아이템 임베딩(Item Latent Factors)이 된다.</p>
<p>결국 MF를 학습하는 것은 latent feature들을 학습하는 것과 같다.</p>
<p>범주형 feature의 잠재 요인을 feature로 사용하고자 할 경우 이 잠재 요인을 가장 손쉽게 구할 수 있는 방법이다.</p>
<hr>
<p>Latent 행렬을 각각 P, Q라고 했을 때, MF는 <strong>Rating Matrix를 $P$와 $Q$로 분해하여 $R$과 최대한 유사하게 $\hat R$을 추론한다.(최적화)</strong></p>
<p>$$
R \approx P \times Q^T = \widehat R
$$</p>
<h2 id="모델-학습-과정">
  모델 학습 과정
  <a class="anchor" href="#%eb%aa%a8%eb%8d%b8-%ed%95%99%ec%8a%b5-%ea%b3%bc%ec%a0%95">#</a>
</h2>
<p>Object Function을 정의하고 최적화 문제를 푸는 모델학습 과정을 살펴보자.</p>
<p>$$
R \approx P \times Q^T = \widehat R\
P \rightarrow |U| \times k\
Q \rightarrow |I| \times k
$$</p>
<p>![MF](/imgs/Matrix Factorization.png)</p>
<h2 id="objective-function">
  Objective Function
  <a class="anchor" href="#objective-function">#</a>
</h2>
<h3 id="기본-형태">
  기본 형태
  <a class="anchor" href="#%ea%b8%b0%eb%b3%b8-%ed%98%95%ed%83%9c">#</a>
</h3>
<p>$$
\tt \min <em>{P, Q} \sum</em>{\text {observed } r_{u, i}}\left(r_{u, i}-p_u^T q_i\right)^2
$$</p>
<ul>
<li>
<p>$r_{u,i}:$   학습 데이터에 있는 유저 $u$의 아이템 $i$에 대한 실제 rating</p>
</li>
<li>
<p>$p_u,q_i:$ 유저($u$)와 아이템($i$)의 latent vector</p>
<p><strong>학습을 통해 알아내고자 하는 목표</strong></p>
<p>최적화 문제를 통해 갱신되는 파라미터</p>
</li>
<li>
<p>$\widehat {r_{u,i}} = p_u^Tq_i$ : 예측된 Rating Matrix</p>
<ul>
<li>
<p>원본 수식처럼 $p \times q^T$ 가 아닌  $p^T \times q$ 인 이유</p>
<p>우선, $r_{u,i}$, $p_{u,x}$, 그리고 $q_{x,i}$는 각각 다음을 의미한다.($Q^T$ 헷갈리지 않게 주의)</p>
<p>$r_{u,i}$ : $R$의 $(u,i)$번째 원소</p>
<p>$p_{u,x}$ : $P$의 $(u,x)$번째 원소</p>
<p>$q_{x,i}$ : $Q^T$의 $(x,i)$번째 원소</p>
<p>또한, 행렬 연산에서 벡터는 보통 &ldquo;열벡터(column vector)&ldquo;를 의미하므로</p>
<p>$P$의 $u$번째 행($p_{u,1:k}$)은 $P^T$의 $u$번째 열($p^T_{1:k,u}$), 즉 $p^T_u$로 표현할 수 있다.</p>
<p>따라서, 해당 공식에서 $R$의 $(u,i)$번째 원소의 추정치인 $\widehat{r_{u,i}}$는</p>
<p>$P^T$의 $u$번째 열벡터($p^T_u$)와 $Q^T$의 $i$번째 열벡터($q_i$)를 곱한 값이라고 할 수 있다.</p>
<p>물론, $\widehat{r_{u,i}}$는 $1 \times 1$ 크기의 행렬이므로 우측 항에 전치를 취해도 결과가 동일하다.</p>
<p>( $\therefore \widehat{r_{u,i}} = p^T_u \cdot q_i = q^T_i \cdot p_u$ )</p>
</li>
</ul>
</li>
</ul>
<h3 id="최종-형태">
  최종 형태
  <a class="anchor" href="#%ec%b5%9c%ec%a2%85-%ed%98%95%ed%83%9c">#</a>
</h3>
<p>$$
\tt \min <em>{P, Q} \sum</em>{\text {observed  }r_{u,i}}\left(r_{u, i}-p_u^T q_i\right)^2
+{\lambda\left(\left|p_u\right|_2^2+\left|q_i\right|_2^2\right)}
$$</p>
<p>$\lambda$(상수)배 된 penalty term은 L2 — 
  <a href="https://www.notion.so/Regularization-6412b5a46836418ea1dc7109fc628846">Regularization(규제)</a></p>
<p>학습 데이터에 과적합되는 것을 방지한다.</p>
<h3 id="mf-학습">
  MF 학습
  <a class="anchor" href="#mf-%ed%95%99%ec%8a%b5">#</a>
</h3>
<p>
  <a href="https://www.notion.so/SGD-Stochastic-gradient-descent-d8497f8a79fc4f879662565532333f64">SGD: Stochastic gradient descent(확률적 경사 하강법)</a></p>
<p>MF 모델에서의 SGD</p>
<ul>
<li>
<p><strong>Error $e_{ui}$</strong></p>
<p>$$
\tt e_{u i}=r_{u i}-p_u^T q_i</p>
<p>$$</p>
</li>
<li>
<p><strong>Loss $L$</strong></p>
<p>$$
\tt L=\sum\left(r_{u, i}-p_u^T q_i\right)^2+\lambda\left(\left|p_u\right|_2^2+\left|q_i\right|_2^2\right) \quad</p>
<p>$$</p>
<p>Loss를 $p_u$로 미분하여 최솟값 계산</p>
</li>
<li>
<p><strong>Gradient</strong></p>
<p>$$
{\tt{\frac{\partial L}{\partial p_u}=\frac{\partial\left(r_{u i}-p_u^T q_i\right)^2}{\partial p_u}+\frac{\partial \lambda\left|p_u\right|<em>2^2}{\partial p_u}}}\\tt{
\=-2\left(r</em>{u i}-p_u^T q_i\right) q_i+2 \lambda p_u}</p>
<p>$$</p>
<p>이를 Error Term을 활용하여 아래와 같이 나타낼 수 있다.</p>
<p>$$
\tt \frac{\partial L}{\partial p_u}=-2\left(e_{u i} q_i-\lambda p_u\right)
$$</p>
</li>
<li>
<p><strong>Gradient의 반대 방향으로 $p_u$, $q_i$를 업데이트</strong></p>
<p>$$
{\tt \p_u \leftarrow p_u+\eta \cdot\left(e_{u i} q_i-\lambda p_u\right)}\
\tt q_i \leftarrow q_i+\eta \cdot\left(e_{u i} p_u-\lambda q_i\right)
$$</p>
<p>부호가 바뀐다.</p>
</li>
</ul>
<hr>
<h2 id="mf-기반-추천으로-가장-널리-알려진-논문">
  MF 기반 추천으로 가장 널리 알려진 논문
  <a class="anchor" href="#mf-%ea%b8%b0%eb%b0%98-%ec%b6%94%ec%b2%9c%ec%9c%bc%eb%a1%9c-%ea%b0%80%ec%9e%a5-%eb%84%90%eb%a6%ac-%ec%95%8c%eb%a0%a4%ec%a7%84-%eb%85%bc%eb%ac%b8">#</a>
</h2>
<p>
  <a href="https://datajobs.com/data-science-repo/Recommender-Systems-%5bNetflix%5d.pdf">Matrix Factorization Techniques for Recommender Systems</a></p>
<p>기본적인 MF에 다양한 테크닉을 추가하여 성능을 향상시켰다.</p>
<ul>
<li>
<h3 id="adding-biases">
  Adding Biases
  <a class="anchor" href="#adding-biases">#</a>
</h3>
<p>어떤 유저는 모든 영화에 대해 평점을 낮게 줄 수도 있다.</p>
<p>아이템도 마찬가지로 편향이 발생할 수 있다.</p>
<p>⇒ 전체 평균 $\mu$, 유저, 아이템의 bias를 추가하여 예측 성능을 높인다.</p>
<ul>
<li>
<p><strong>기존 목적 함수</strong></p>
<p>$$
\tt \min <em>{P, Q} \sum</em>{\text {observed  }r_{u,i}}\left(r_{u, i}-p_u^T q_i\right)^2+\lambda\left(\left|p_u\right|_2^2+\left|q_i\right|_2^2\right)
$$</p>
</li>
<li>
<p><strong>Bias가 추가된 목적 함수</strong></p>
<p>$$
{\tt \min <em>{P, Q} \sum</em>{\text {observed } r_{u,i}}\left(r_{u, i}-{\mu - b_u-b_i}-p_u^T q_i\right)^2}
\+\tt \lambda\left(|| p_u\left|_2^2+|| q_i\right|_2^2+{b_u^2+b_i^2}\right)
$$</p>
<p>마찬가지로 bias가 규제 term에 추가되어 과적합되지 않게 한다.</p>
</li>
<li>
<p><strong>Error</strong></p>
<p>$$
\tt e_{u,i} = r_{u,i} - \mu - b_u - b_i - p_u^Tq_i
$$</p>
</li>
<li>
<p><strong>Gradient의 반대방향으로 $\tt b_u, b_i, x_u, y_i$를 업데이트</strong></p>
<p>$$
\begin{aligned}&amp; {b_u \leftarrow b_u+\gamma \cdot\left(e_{u i}-\lambda b_u\right)} \&amp; {b_i \leftarrow b_i+\gamma \cdot\left(e_{u i}-\lambda b_i\right) }
\&amp; p_u \leftarrow p_u+\gamma \cdot\left(e_{u i} q_i-\lambda p_u\right) \&amp; q_i \leftarrow q_i+\gamma \cdot\left(e_{u i} p_u-\lambda q_i\right)\end{aligned}
$$</p>
</li>
</ul>
</li>
<li>
<h3 id="adding-confidence-level">
  Adding Confidence Level
  <a class="anchor" href="#adding-confidence-level">#</a>
</h3>
<p>모든 평점이 동일한 신뢰도를 갖지 않는다. ⇒ $r_{u,i}$에 대한 신뢰도를 의미하는 $c_{u,i}$를 추가</p>
<ul>
<li>
<p>대규모 광고 집행과 같이 특정 아이템이 많이 노출되어 클릭되는 경우</p>
</li>
<li>
<p>유저의 아이템에 대한 평점이 정확하지 않은 경우(implicit Feedback)</p>
</li>
<li>
<p><strong>기존 목적 함수</strong></p>
<p>$$
{\tt \min <em>{P, Q} \sum</em>{\text {observed } r_{u,i}}\left(r_{u, i}-\mu-b_u-b_i-p_u^T q_i\right)^2} \+\tt\lambda\left(|| p_u\left|_2^2+|| q_i\right|_2^2+b_u^2+b_i^2\right)
$$</p>
</li>
<li>
<p><strong>Confidence Level이 추가된 목적함수</strong></p>
<p>$$
{\tt \min <em>{P, Q} \sum</em>{\text {observed } r_{u, i}}  {c_{u, i}}\left(r_{u, i}-\mu-b_u-b_i-p_u^T q_i\right)^2}\+\tt\lambda\left(|| p_u\left|_2^2+|| q_i\right|_2^2+b_u^2+b_i^2\right)
$$</p>
</li>
</ul>
</li>
<li>
<h3 id="adding-temporal-dynamics">
  Adding Temporal Dynamics
  <a class="anchor" href="#adding-temporal-dynamics">#</a>
</h3>
<p>시간에 따라 변하는 유저, 아이템의 특성을 반영하고 싶다.</p>
<p>아이템이 시간이 지남에 따라 인기도가 떨어진다.</p>
<p>유저가 시간이 흐르면서 평점을 내리는 기준이 엄격해진다.</p>
<p>시간을 반영한 평점 예측</p>
<p>학습 파라미터가 시간을 반영하도록 모델 설계</p>
<p>$$
\tt \widehat r_{ui}(t) = \mu + b_u(t) + b_i(t) + p^T_uq_i(t)
$$</p>
</li>
</ul>
<h2 id="단점">
  단점
  <a class="anchor" href="#%eb%8b%a8%ec%a0%90">#</a>
</h2>
<ul>
<li><strong>p, q 변수가 2개라서 빠른계산이 불가능하다.</strong>
<ul>
<li>SGD를 학습하는 과정에서 업데이트를 여러 번 하기 때문에
빠른 계산이 불가능하다는 단점이 누적된다.</li>
</ul>
</li>
<li>유저 수와 아이템 수가 커질수록 반복문으로 인한 연산량 증가</li>
</ul>
<details>
<summary>예시</summary>
<blockquote>
<p>여기서는 정답 횟수를 행렬의 값으로 사용하였지만 문제별로 사용한 시간의 평균 혹은 다른 feature를 값으로 활용한다면 다른 잠재 요인 값들을 얻어낼 수 있다.</p>
<ul>
<li>$R \approx PQ^{T}$
<ul>
<li>$R$ : 유저들에 대한 문제별 정답 횟수 행렬</li>
<li>$P$ : 유저와 잠재 요인의 행렬</li>
<li>$Q$ : 문제와 잠재 요인의 행렬</li>
</ul>
</li>
</ul>
</blockquote>
</details>
<p><strong>참고하면 좋은 자료</strong></p>
<ul>
<li>
  <a href="https://medium.com/analytics-vidhya/understanding-of-matrix-factorization-mf-and-singular-value-decomposition-svd-1a38c2d5bbaa">Understanding of Matrix Factorization (MF) and Singular Value Decomposition (SVD) - Medium</a></li>
<li>
  <a href="https://medium.com/swlh/latent-matrix-factorization-6fa1cd0b2e5f">Latent Matrix Factorization - Medium</a></li>
</ul>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#모델-학습-과정">모델 학습 과정</a></li>
        <li><a href="#objective-function">Objective Function</a>
          <ul>
            <li><a href="#기본-형태">기본 형태</a></li>
            <li><a href="#최종-형태">최종 형태</a></li>
            <li><a href="#mf-학습">MF 학습</a></li>
          </ul>
        </li>
        <li><a href="#mf-기반-추천으로-가장-널리-알려진-논문">MF 기반 추천으로 가장 널리 알려진 논문</a>
          <ul>
            <li><a href="#adding-biases">Adding Biases</a></li>
            <li><a href="#adding-confidence-level">Adding Confidence Level</a></li>
            <li><a href="#adding-temporal-dynamics">Adding Temporal Dynamics</a></li>
          </ul>
        </li>
        <li><a href="#단점">단점</a></li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












