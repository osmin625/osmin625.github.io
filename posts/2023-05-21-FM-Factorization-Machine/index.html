<!DOCTYPE html>
<html lang="en" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="General Predictor에 Latent Factor Model을 추가한 모델.
Background#Factorization Machines
SVM과 Factorization Model의 장점을 결합한 FM을 처음 소개한 논문
등장 배경
딥러닝이 등장하기 이전 SVM이 가장 많이 사용됐다.
매우 희소한 데이터가 많은 CF 환경에서는 SVM보다 MF 계열의 모델이 더 높은 성능을 내왔다.
SVM과 MF의 장점을 결합할 수 없을까? ⇒ FM 탄생.
MF 기반 모델의 한계 ⇒ User-Item 행렬 기반
즉, 특정 데이터 포맷에 특화되어 있다.
$X:$ (유저, 아이템) → $Y:$ (rating)으로 이루어진 데이터에 대해서만 적용이 가능하다.">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:title" content="FM: Factorization Machine" />
<meta property="og:description" content="General Predictor에 Latent Factor Model을 추가한 모델.
Background#Factorization Machines
SVM과 Factorization Model의 장점을 결합한 FM을 처음 소개한 논문
등장 배경
딥러닝이 등장하기 이전 SVM이 가장 많이 사용됐다.
매우 희소한 데이터가 많은 CF 환경에서는 SVM보다 MF 계열의 모델이 더 높은 성능을 내왔다.
SVM과 MF의 장점을 결합할 수 없을까? ⇒ FM 탄생.
MF 기반 모델의 한계 ⇒ User-Item 행렬 기반
즉, 특정 데이터 포맷에 특화되어 있다.
$X:$ (유저, 아이템) → $Y:$ (rating)으로 이루어진 데이터에 대해서만 적용이 가능하다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://osmin625.github.io/posts/2023-05-21-FM-Factorization-Machine/" /><meta property="article:section" content="posts" />

<meta property="article:modified_time" content="2024-01-10T01:07:46+09:00" />

<title>FM: Factorization Machine | OMIN</title>
<link rel="manifest" href="/manifest.json">
<link rel="icon" href="/favicon.png" >
<link rel="stylesheet" href="/book.min.33a48f5432973b8ff9a82679d9e45d67f2c15d4399bd2829269455cfe390b5e8.css" integrity="sha256-M6SPVDKXO4/5qCZ52eRdZ/LBXUOZvSgpJpRVz&#43;OQteg=" crossorigin="anonymous"><!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>OMIN</span>
  </a>
</h2>













  












  
<ul>
  
  <li>
    <a href="/posts/"  >
        Blog
      </a>
  </li>
  
  <li>
    <a href="https://github.com/osmin625/"  target="_blank" rel="noopener">
        Github
      </a>
  </li>
  
</ul>






</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
    <label for="menu-control">
      
      <link rel="icon" href="/favicon.ico" type="image/x-icon">
    </label>
  
    <strong>FM: Factorization Machine</strong>
  
    <label for="toc-control">
      
      <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
      
    </label>
  </div>
  

  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#background">Background</a></li>
            <li><a href="#fm-공식">FM 공식</a></li>
            <li><a href="#fm의-활용">FM의 활용</a></li>
            <li><a href="#fm의-시간-복잡도">FM의 시간 복잡도</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
<article class="markdown book-post">
  <h1>
    <a href="/posts/2023-05-21-FM-Factorization-Machine/">FM: Factorization Machine</a>
  </h1>
  


  
  <div>
    
      <a href="/categories/DL-Algorithm/">DL Algorithm</a>, 
      <a href="/categories/Recommendation-System/">Recommendation System</a>
  </div>
  

  
  <div>
    
      <a href="/tags/Context-aware-Recsys/">Context-aware Recsys</a>, 
      <a href="/tags/Factorization-Machine/">Factorization Machine</a>, 
      <a href="/tags/Latent-Factor-Model/">Latent Factor Model</a>
  </div>
  



<blockquote>
<p><strong>General Predictor에 Latent Factor Model을 추가한 모델.</strong></p>
</blockquote>
<h3 id="background">
  Background
  <a class="anchor" href="#background">#</a>
</h3>
<p>Factorization Machines</p>
<p>SVM과 Factorization Model의 장점을 결합한 FM을 처음 소개한 논문</p>
<p>등장 배경</p>
<p>딥러닝이 등장하기 이전 SVM이 가장 많이 사용됐다.</p>
<p>매우 희소한 데이터가 많은 CF 환경에서는 SVM보다 MF 계열의 모델이 더 높은 성능을 내왔다.</p>
<p>SVM과 MF의 장점을 결합할 수 없을까? ⇒ FM 탄생.</p>
<p><strong>MF 기반 모델의 한계 ⇒ User-Item 행렬 기반</strong></p>
<p>즉, 특정 데이터 포맷에 특화되어 있다.</p>
<p>$X:$ (유저, 아이템) → $Y:$ (rating)으로 이루어진 데이터에 대해서만 적용이 가능하다.</p>
<p>
  <img src="/imgs/FM_5.png" alt="FM" /></p>
<ol>
<li>일반적인 데이터셋에 바로 적용 불가능</li>
<li>User-Item 행렬 외의 정보를 활용하기 어렵다.</li>
</ol>
<p><strong>User-Item 행렬을 범용적인 형태로 변경했을 때의 문제점</strong></p>
<ul>
<li>ML 모델에 사용되는 데이터 형태를 만들면 high sparsity 문제가 발생한다.</li>
<li>원활한 파라미터 학습이 어렵다.</li>
<li>Feature간 상호작용을 반영하기 어렵다.</li>
</ul>
<h3 id="fm-공식">
  FM 공식
  <a class="anchor" href="#fm-%ea%b3%b5%ec%8b%9d">#</a>
</h3>
<p>$$
\hat{y}(\mathrm{x})=w_0+\sum_{i=1}^n w_i x_i\blue{+\sum_{i=1}^n \sum_{j=i+1}^n\left\langle\mathrm{v}_i, \mathrm{v}_j\right\rangle x_i x_j} \</p>
<p>w_0 \in \mathbb{R}, \quad w_i \in \mathbb{R}, \quad \mathrm{v}_i \in \mathbb{R}^k
$$</p>
<ul>
<li>
<p>$\langle \cdot,\cdot \rangle:$ 두 벡터의 스칼라곱(dot product)</p>
<p>$$
\left\langle\mathrm{v}<em>i, \mathrm{v}<em>j\right\rangle:=\sum</em>{f=1}^k \mathrm{v}</em>{i, f} \cdot \mathrm{v}_{j, f}
$$</p>
</li>
</ul>
<p>
  <img src="/imgs/FM_1.png" alt="FM" /></p>
<ul>
<li>
<p>Logistic Regression에 두 Feature의 상호작용을 나타내는 Term이 추가된 형태</p>
<ul>
<li>
<p>Logistic Regression</p>
<p>$$
\hat{y}(\mathrm{x})=w_0+\sum_{i=1}^n w_i x_i\</p>
<p>w_0 \in \mathbb{R}, \quad w_i \in \mathbb{R}
$$</p>
</li>
</ul>
</li>
<li>
<p>Polynomial Model과 상호작용을 모델링하는 Term이 다르다.</p>
<ul>
<li>
<p>Polynomial Regression</p>
<p>$$
\hat y(x)=\left(w_0+\sum_{i=1}^n w_i x_i{+\sum_{i=1}^n \sum_{j=i+1}^n w_{i j} x_i x_j}\right), \quad w_i, w_{i j} \in \mathbb{R}
$$</p>
<p>
  <img src="/imgs/FM_2.png" alt="FM" /></p>
</li>
<li>
<p>$x_ix_j$의 상호작용을 하나의 파라미터$(w_{ij})$로 나타낸 Polynomial에 비해,
$\left\langle\mathrm{v}_i, \mathrm{v}_j\right\rangle$의 k차원의 Factorization 파라미터로 나타내 더욱 일반화시켰다.</p>
</li>
</ul>
</li>
</ul>
<h3 id="fm의-활용">
  FM의 활용
  <a class="anchor" href="#fm%ec%9d%98-%ed%99%9c%ec%9a%a9">#</a>
</h3>
<p><strong>Sparse한 데이터셋에서 예측하기</strong></p>
<p>유저의 영화에 대한 평점 데이터는 대표적인 High Sparsity 데이터</p>
<p>유저 - 아이템 매트릭스에서 다루던 Sparse Matrix와는 다른 의미</p>
<p>평점 데이터 = { (유저1, 영화2, 5), (유저3, 영화1, 4), (유저2, 영화3, 1), … }</p>
<p>일반적인 CF 문제의 입력 데이터와 같음</p>
<p>위의 평점 데이터를 일반적인 입력 데이터로 바꾸면, 입력 값의 차원이 전체 유저와 아이템 수만큼 증가</p>
<p>ex) 유저 수가 $U$명, 영화의 수가 $M$개일 때</p>
<p>
  <img src="/imgs/FM_3.png" alt="FM" /></p>
<hr>
<ul>
<li>
<p><strong>Sparse한 Feature들의 상호작용이 학습되는 방법</strong></p>
<p>유저 A의 ST에 대한 평점 예측 → $V_A, V_{ST}$가 FM 모델을 통해 학습되기 때문에 상호작용이 반영된다.</p>
<p>$V_{ST}$ — 유저 B,C의 영화 ST에 대한 평점 데이터를 통해 학습된다.</p>
<p>유저 B,C는 영화 ST 외에 다른 영화도 평가한다.</p>
<p>$V_A$ — 유저 B,C가 유저 A와 공유하는 영화 SW의 평점 데이터를 통해 학습한다.</p>
<p>
  <img src="/imgs/FM_4.png" alt="FM" /></p>
</li>
</ul>
<p><strong>FM의 장점</strong></p>
<p><strong>vs. SVM</strong></p>
<ul>
<li>
<p>매우 sparse한 데이터에 대해서 높은 예측 성능을 보인다.</p>
</li>
<li>
<p>선형 복잡도$(O(kn))$를 가지므로 수십 억 개의 학습 데이터에 대해서도 빠르게 학습한다.</p>
<p>모델의 학습에 필요한 파라미터의 개수도 선형적으로 비례한다.</p>
</li>
</ul>
<p><strong>vs. Matrix Factorization</strong></p>
<ul>
<li>
<p>여러 예측 문제(회귀/분류/랭킹)에 모두 활용 가능한 범용적인 지도 학습 모델</p>
</li>
<li>
<p>일반적인 실수 변수(real-value feature)를 모델의 입력(input)으로 사용한다.</p>
<p>MF와 비교했을 때 유저, 아이템 ID 외에 다른 부가 정보들을 모델의 피쳐로 사용할 수 있다.</p>
</li>
</ul>
<h3 id="fm의-시간-복잡도">
  FM의 시간 복잡도
  <a class="anchor" href="#fm%ec%9d%98-%ec%8b%9c%ea%b0%84-%eb%b3%b5%ec%9e%a1%eb%8f%84">#</a>
</h3>
<p>$$
\begin{aligned}&amp; \tt\sum_{i=1}^n \sum_{j=i+1}^n\left\langle\mathbf{v}<em>i, \mathbf{v}<em>j\right\rangle x_i x_j \quad\quad \quad\quad\quad\quad\quad\quad{\Longrightarrow O(kn^2)} \= &amp; \frac{1}{2} \sum</em>{i=1}^n \sum</em>{j=1}^n\left\langle\mathbf{v}<em>i, \mathbf{v}<em>j\right\rangle x_i x_j-\frac{1}{2} \sum</em>{i=1}^n\left\langle\mathbf{v}<em>i, \mathbf{v}<em>i\right\rangle x_i x_i \= &amp; \tt\frac{1}{2}\left(\sum</em>{i=1}^n \sum</em>{j=1}^n \sum</em>{f=1}^k v_{i, f} v_{j, f} x_i x_j-\sum_{i=1}^n \sum_{f=1}^k v_{i, f} v_{i, f} x_i x_i\right) \= &amp; \tt\frac{1}{2} \sum_{f=1}^k\left(\left(\sum_{i=1}^n v_{i, f} x_i\right)\left(\sum_{j=1}^n v_{j, f} x_j\right)-\sum_{i=1}^n v_{i, f}^2 x_i^2\right) \= &amp; \tt\frac{1}{2} \sum_{f=1}^k\left(\left(\sum_{i=1}^n v_{i, f} x_i\right)^2-\sum_{i=1}^n v_{i, f}^2 x_i^2\right)\quad\quad{\Longrightarrow O(kn)}\end{aligned}
$$</p>
<p>어떻게 수식을 정리하여 시간복잡도를 줄일 수 있었나?</p>
<p>2중 반복문을 (1중 반복문)^2의 형태로 치환하여 계산을 줄였다.</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li>
          <ul>
            <li><a href="#background">Background</a></li>
            <li><a href="#fm-공식">FM 공식</a></li>
            <li><a href="#fm의-활용">FM의 활용</a></li>
            <li><a href="#fm의-시간-복잡도">FM의 시간 복잡도</a></li>
          </ul>
        </li>
      </ul>
    </li>
  </ul>
</nav>


 
      </div>
    </aside>
    
  </main>

  
</body>
</html>












