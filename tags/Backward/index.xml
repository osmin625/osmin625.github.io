<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Backward on OMIN</title>
    <link>https://osmin625.github.io/tags/backward/</link>
    <description>Recent content in Backward on OMIN</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ko</language>
    <atom:link href="https://osmin625.github.io/tags/backward/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>PyTorch의 Backward에 대해 알아보자.</title>
      <link>https://osmin625.github.io/posts/2023-06-13-backward/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://osmin625.github.io/posts/2023-06-13-backward/</guid>
      <description>✔️ 간단 요약&#xA;forward함수를 정의하면 자동으로 정의된다.&#xA;동작 과정&#xA;tensor(loss에 해당)가 포함된 식을 미분한다. 미분 값을 tensor에 저장한다.&#xA;{: .prompt-info } Autograd, loss, optimizer, nn.Module tensor(loss에 해당)가 포함된 식을 미분한다.&#xA;Tensor 객체의 backward 함수에는 default로 Autograd 설정이 되어 있기 때문에, 미분 수식을 따로 작성하지 않아도 자동으로 미분이 가능하다.&#xA;기본 예제&#xA;w = torch.tensor(2.0, requires_grad=True) y = w**2 z = 10*y + 25 z.backward() w.grad() # output : tensor(40.) $$ w = 2\ y = w^2\ z = 10\times y + 25\ z = 10 \times w^2 + 25\ {dz\over dw} = 20 \times w = 40 $$</description>
    </item>
    <item>
      <title>모델 학습 시 1 epoch에 어떤 일이 발생하나요?</title>
      <link>https://osmin625.github.io/posts/2023-09-24-1-epoch/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://osmin625.github.io/posts/2023-09-24-1-epoch/</guid>
      <description>criterion = torch.nn.MSELoss() optimizer = torch.optim.SGD(model.parameters(), lr=learningRate) ... for epoch in range(epochs): optimizer.zero_grad() outputs = model(inputs) loss = criterion(outputs, labels) loss.backward() optimizer.step() 1. optimizer.zero_grad() : 이전 epoch의 미분값 초기화 optimizer에서 업데이트하는 파라미터에 저장된 그래디언트를 모두 0으로 만들어준다.&#xA;해당 코드는 왜 필요할까?&#xA;zero_grad()를 실행해주지 않으면 이후의 backward에서 해당 step의 gradient 값이 계속 누적으로 더해져 모델이 이상하게 학습할 수 있기 때문이다.&#xA;왜 굳이 default를 이전의 gradient가 넘어오도록 설정했을까?&#xA;RNN 계열의 모델이나, 가중치 공유가 필요한 모델의 경우 이전 gradient를 그대로 가져오는 것이 필요하기 때문이다.</description>
    </item>
  </channel>
</rss>
