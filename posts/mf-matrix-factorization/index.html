<!DOCTYPE html>
<html lang="en"><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    
    
    
    
    
    

    
    <title>MF: Matrix Factorization</title>
    <meta name="description" content="Interested in ML Engineering, Data Science.">
    <meta name="keywords" content='blog, gokarna, hugo, collaborative filtering, matrix factorization'>

    <meta property="og:url" content="https://osmin625.github.io/posts/MF-Matrix-Factorization/">
    <meta property="og:type" content="website">
    <meta property="og:title" content="MF: Matrix Factorization">
    <meta property="og:description" content="Interested in ML Engineering, Data Science.">
    <meta property="og:image" content="https://osmin625.github.io/images/from_scratch.webp">
    <meta property="og:image:secure_url" content="https://osmin625.github.io/images/from_scratch.webp">

    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="MF: Matrix Factorization">
    <meta name="twitter:description" content="Interested in ML Engineering, Data Science.">
    <meta property="twitter:domain" content="https://osmin625.github.io/posts/MF-Matrix-Factorization/">
    <meta property="twitter:url" content="https://osmin625.github.io/posts/MF-Matrix-Factorization/">
    <meta name="twitter:image" content="https://osmin625.github.io/images/from_scratch.webp">

    
    <link rel="canonical" href="https://osmin625.github.io/posts/MF-Matrix-Factorization/" />

    
    <link rel="stylesheet" type="text/css" href="/css/normalize.min.css" media="print">

    
    <link rel="stylesheet" type="text/css" href="/css/main.min.css">

    
    <link id="dark-theme" rel="stylesheet" href="/css/dark.min.css">

    
    <script src="/js/bundle.min.4ffdc838c15e2e2971b91a99fe21b6cfe58ddb8410dd0e3487b6b9b92cc3caaa.js" integrity="sha256-T/3IOMFeLilxuRqZ/iG2z&#43;WN24QQ3Q40h7a5uSzDyqo="></script>

    
    
</head>
<body>
        <script type="text/javascript">
            
            setThemeByUserPref();
            
            const sessionId = getSessionId();
            console.log('현재 세션 ID:', sessionId);
        </script><header class="header">
    <nav class="header-nav">

        
        <div class="avatar">
            <a href="https://osmin625.github.io">
                <img src='/images/from_scratch.webp' alt="OMIN" />
            </a>
        </div>
        

        <div class="nav-title">
            <a class="nav-brand" href="https://osmin625.github.io">Robust dev O</a>
        </div>

        <div class="nav-links">
            
            <div class="nav-link">
                <a href="https://osmin625.github.io/"><span data-feather='home'></span> Home </a>
            </div>
            
            <div class="nav-link">
                <a href="https://osmin625.github.io/categories/"><span data-feather='list'></span> Categories </a>
            </div>
            
            <div class="nav-link">
                <a href="https://osmin625.github.io/tags/"><span data-feather='tag'></span> Tags </a>
            </div>
            
            <div class="nav-link">
                <a href="https://osmin625.github.io/posts/"><span data-feather='book'></span> archive </a>
            </div>
            

            <span class="nav-icons-divider"></span>
            <div class="nav-link dark-theme-toggle">
                <span id="dark-theme-toggle-screen-reader-target" class="sr-only"></span>
                <a>
                    <span id="theme-toggle-icon" data-feather="moon"></span>
                </a>
            </div>

            <div class="nav-link" id="hamburger-menu-toggle">
                <span id="hamburger-menu-toggle-screen-reader-target" class="sr-only">menu</span>
                <a>
                    <span data-feather="menu"></span>
                </a>
            </div>

            
            <ul class="nav-hamburger-list visibility-hidden">
                
                <li class="nav-item">
                    <a href="https://osmin625.github.io/"><span data-feather='home'></span> Home </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://osmin625.github.io/categories/"><span data-feather='list'></span> Categories </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://osmin625.github.io/tags/"><span data-feather='tag'></span> Tags </a>
                </li>
                
                <li class="nav-item">
                    <a href="https://osmin625.github.io/posts/"><span data-feather='book'></span> archive </a>
                </li>
                
                <li class="nav-item dark-theme-toggle">
                    <span id="dark-theme-toggle-screen-reader-target" class="sr-only">theme</span>
                    <a>
                        <span id="theme-toggle-icon" data-feather="moon"></span>
                    </a>
                </li>
            </ul>

        </div>
    </nav>
</header>
<main id="content">
    <div class="post container">
    <div class="post-header-section">
        <h1>MF: Matrix Factorization</h1>
        <small role="doc-subtitle"></small>
        <p class="post-date">3월 30, 2023
        
        </p>

        <ul class="post-tags">
        
            <li class="post-tag"><a href="https://osmin625.github.io/tags/collaborative-filtering">collaborative filtering</a></li>
        
            <li class="post-tag"><a href="https://osmin625.github.io/tags/matrix-factorization">matrix factorization</a></li>
        
        </ul>
    </div>

    <div class="post-content">
        <p>
            <blockquote>
<p>간단 요약</p>
<p>행렬을 인수분해 후 재생성하여 결측치를 예측하는 방법</p>
<p>인수분해를 다양하게 시도하여 대상 행렬을 가장 잘 복구하는 최적의 하위행렬을 찾는 과정
{: .prompt-info }
Latent Factors, Matrix Factorization, SGD</p>
</blockquote>
<p><strong>행렬을 인수분해 후 재생성하여 결측치를 예측하는 방법</strong></p>
<ol>
<li>
<p>대상 행렬을 두개의 하위 행렬로 분해한다.</p>
<p>User-Item 행렬을 User와 Item 각각에 대한 저차원의 latent factor 행렬로 분해한다.</p>
</li>
<li>
<p>두 하위 행렬을 다시 곱해서 대상 행렬과 동일한 크기의 단일 행렬로 만든다.</p>
</li>
<li>
<p><strong>위의 과정에서 기존 행렬의 빈공간이 채워진다.</strong></p>
<p>이는 행렬의 성질을 이용한 것이다.</p>
<p>즉, 결측값(비평가 항목)에 대해 임의로 Imputation을 수행하지 않는다.</p>
<p>실제로 관측된 값만 활용한다.</p>
</li>
</ol>
<p>요약하면, 인수분해를 다양하게 시도하여 대상 행렬을 가장 잘 복구하는 최적의 하위행렬을 찾는 과정이다.</p>
<p>기계가 해석하기 위한 행렬, 즉 블랙 박스 모델에 더 가깝다.</p>
<p>추천시스템에서 두 개의 하위행렬은 각각 유저 임베딩(User Latent Factors)과 아이템 임베딩(Item Latent Factors)이 된다.</p>
<p>결국 MF를 학습하는 것은 latent feature들을 학습하는 것과 같다.</p>
<p>범주형 feature의 잠재 요인을 feature로 사용하고자 할 경우 이 잠재 요인을 가장 손쉽게 구할 수 있는 방법이다.</p>
<hr>
<p>Latent 행렬을 각각 P, Q라고 했을 때, MF는 <strong>Rating Matrix를 <code>$P$</code>와 <code>$Q$</code>로 분해하여 <code>$R$</code>과 최대한 유사하게 <code>$\hat R$</code>을 추론한다.(최적화)</strong></p>
<p><code>$$ R \approx P \times Q^T = \widehat R $$</code></p>
<h2 id="모델-학습-과정">모델 학습 과정</h2>
<p>Object Function을 정의하고 최적화 문제를 푸는 모델학습 과정을 살펴보자.</p>
<p><code>$$ R \approx P \times Q^T = \widehat R\\ P \rightarrow |U| \times k\\ Q \rightarrow |I| \times k $$</code></p>
<p>![MF](/imgs/Matrix Factorization.png)</p>
<h2 id="objective-function">Objective Function</h2>
<h3 id="기본-형태">기본 형태</h3>
<p><code>$$ \tt \min _{P, Q} \sum_{\text {observed } r_{u, i}}\left(r_{u, i}-p_u^T q_i\right)^2 $$</code></p>
<ul>
<li>
<p><code>$r_{u,i}:$</code>   학습 데이터에 있는 유저 <code>$u$</code>의 아이템 <code>$i$</code>에 대한 실제 rating</p>
</li>
<li>
<p><code>$p_u,q_i:$</code> 유저(<code>$u$</code>)와 아이템(<code>$i$</code>)의 latent vector</p>
<p><strong>학습을 통해 알아내고자 하는 목표</strong></p>
<p>최적화 문제를 통해 갱신되는 파라미터</p>
</li>
<li>
<p><code>$\widehat {r_{u,i}} = p_u^Tq_i$</code> : 예측된 Rating Matrix</p>
<ul>
<li>
<p>원본 수식처럼 <code>$p \times q^T$</code> 가 아닌  <code>$p^T \times q$</code> 인 이유</p>
<p>우선, <code>$r_{u,i}$</code>, <code>$p_{u,x}$</code>, 그리고 <code>$q_{x,i}$</code>는 각각 다음을 의미한다.(<code>$Q^T$</code> 헷갈리지 않게 주의)</p>
<p><code>$r_{u,i}$</code> : <code>$R$</code>의 <code>$(u,i)$</code>번째 원소</p>
<p><code>$p_{u,x}$</code> : <code>$P$</code>의 <code>$(u,x)$</code>번째 원소</p>
<p><code>$q_{x,i}$</code> : <code>$Q^T$</code>의 <code>$(x,i)$</code>번째 원소</p>
<p>또한, 행렬 연산에서 벡터는 보통 &ldquo;열벡터(column vector)&ldquo;를 의미하므로</p>
<p><code>$P$</code>의 <code>$u$</code>번째 행(<code>$p_{u,1:k}$</code>)은 <code>$P^T$</code>의 <code>$u$</code>번째 열(<code>$p^T_{1:k,u}$</code>), 즉 <code>$p^T_u$</code>로 표현할 수 있다.</p>
<p>따라서, 해당 공식에서 <code>$R$</code>의 <code>$(u,i)$</code>번째 원소의 추정치인 <code>$\widehat{r_{u,i}}$</code>는</p>
<p><code>$P^T$</code>의 <code>$u$</code>번째 열벡터(<code>$p^T_u$</code>)와 <code>$Q^T$</code>의 <code>$i$</code>번째 열벡터(<code>$q_i$</code>)를 곱한 값이라고 할 수 있다.</p>
<p>물론, <code>$\widehat{r_{u,i}}$</code>는 <code>$1 \times 1$</code> 크기의 행렬이므로 우측 항에 전치를 취해도 결과가 동일하다.</p>
<p>( <code>$\therefore \widehat{r_{u,i}} = p^T_u \cdot q_i = q^T_i \cdot p_u$</code> )</p>
</li>
</ul>
</li>
</ul>
<h3 id="최종-형태">최종 형태</h3>
<p><code>$$ \tt \min _{P, Q} \sum_{\text {observed  }r_{u,i}}\left(r_{u, i}-p_u^T q_i\right)^2 +{\lambda\left(\left\|p_u\right\|_2^2+\left\|q_i\right\|_2^2\right)} $$</code></p>
<p><code>$\lambda$</code>(상수)배 된 penalty term은 L2 — <a href="https://www.notion.so/Regularization-6412b5a46836418ea1dc7109fc628846">Regularization(규제)</a></p>
<p>학습 데이터에 과적합되는 것을 방지한다.</p>
<h3 id="mf-학습">MF 학습</h3>
<p><a href="https://www.notion.so/SGD-Stochastic-gradient-descent-d8497f8a79fc4f879662565532333f64">SGD: Stochastic gradient descent(확률적 경사 하강법)</a></p>
<p>MF 모델에서의 SGD</p>
<ul>
<li>
<p><strong>Error <code>$e_{ui}$</code></strong></p>
<p>`$$
\tt e_{u i}=r_{u i}-p_u^T q_i</p>
<p>$$`</p>
</li>
<li>
<p><strong>Loss <code>$L$</code></strong></p>
<p><code>$$ \tt L=\sum\left(r_{u, i}-p_u^T q_i\right)^2+\lambda\left(\left\|p_u\right\|_2^2+\left\|q_i\right\|_2^2\right) \quad $$</code></p>
<p>Loss를 <code>$p_u$</code>로 미분하여 최솟값 계산</p>
</li>
<li>
<p><strong>Gradient</strong></p>
<p><code>$$ {\tt{\frac{\partial L}{\partial p_u}=\frac{\partial\left(r_{u i}-p_u^T q_i\right)^2}{\partial p_u}+\frac{\partial \lambda\left\|p_u\right\|_2^2}{\partial p_u}}}\\\tt{ \\=-2\left(r_{u i}-p_u^T q_i\right) q_i+2 \lambda p_u} $$</code></p>
<p>이를 Error Term을 활용하여 아래와 같이 나타낼 수 있다.</p>
<p><code>$$ \tt \frac{\partial L}{\partial p_u}=-2\left(e_{u i} q_i-\lambda p_u\right) $$</code></p>
</li>
<li>
<p><strong>Gradient의 반대 방향으로 <code>$p_u$</code>, <code>$q_i$</code>를 업데이트</strong></p>
<p><code>$$ {\tt \\p_u \leftarrow p_u+\eta \cdot\left(e_{u i} q_i-\lambda p_u\right)}\\ \tt q_i \leftarrow q_i+\eta \cdot\left(e_{u i} p_u-\lambda q_i\right) $$</code></p>
<p>부호가 바뀐다.</p>
</li>
</ul>
<hr>
<h2 id="mf-기반-추천으로-가장-널리-알려진-논문">MF 기반 추천으로 가장 널리 알려진 논문</h2>
<p><a href="https://datajobs.com/data-science-repo/Recommender-Systems-%5bNetflix%5d.pdf">Matrix Factorization Techniques for Recommender Systems</a></p>
<p>기본적인 MF에 다양한 테크닉을 추가하여 성능을 향상시켰다.</p>
<ul>
<li>
<h3 id="adding-biases">Adding Biases</h3>
<p>어떤 유저는 모든 영화에 대해 평점을 낮게 줄 수도 있다.</p>
<p>아이템도 마찬가지로 편향이 발생할 수 있다.</p>
<p>⇒ 전체 평균 <code>$\mu$</code>, 유저, 아이템의 bias를 추가하여 예측 성능을 높인다.</p>
<ul>
<li>
<p><strong>기존 목적 함수</strong></p>
<p><code>$$ \tt \min _{P, Q} \sum_{\text {observed  }r_{u,i}}\left(r_{u, i}-p_u^T q_i\right)^2+\lambda\left(\left\|p_u\right\|_2^2+\left\|q_i\right\|_2^2\right) $$</code></p>
</li>
<li>
<p><strong>Bias가 추가된 목적 함수</strong></p>
<p><code>$$ {\tt \min _{P, Q} \sum_{\text {observed } r_{u,i}}\left(r_{u, i}-{\mu - b_u-b_i}-p_u^T q_i\right)^2} \\+\tt \lambda\left(|| p_u\left\|_2^2+|| q_i\right\|_2^2+{b_u^2+b_i^2}\right) $$</code></p>
<p>마찬가지로 bias가 규제 term에 추가되어 과적합되지 않게 한다.</p>
</li>
<li>
<p><strong>Error</strong></p>
<p><code>$$ \tt e_{u,i} = r_{u,i} - \mu - b_u - b_i - p_u^Tq_i $$</code></p>
</li>
<li>
<p><strong>Gradient의 반대방향으로 <code>$\tt b_u, b_i, x_u, y_i$</code>를 업데이트</strong></p>
<p><code>$$ \begin{aligned}&amp; {b_u \leftarrow b_u+\gamma \cdot\left(e_{u i}-\lambda b_u\right)} \\&amp; {b_i \leftarrow b_i+\gamma \cdot\left(e_{u i}-\lambda b_i\right) } \\&amp; p_u \leftarrow p_u+\gamma \cdot\left(e_{u i} q_i-\lambda p_u\right) \\&amp; q_i \leftarrow q_i+\gamma \cdot\left(e_{u i} p_u-\lambda q_i\right)\end{aligned} $$</code></p>
</li>
</ul>
</li>
<li>
<h3 id="adding-confidence-level">Adding Confidence Level</h3>
<p>모든 평점이 동일한 신뢰도를 갖지 않는다. ⇒ <code>$r_{u,i}$</code>에 대한 신뢰도를 의미하는 <code>$c_{u,i}$</code>를 추가</p>
<ul>
<li>
<p>대규모 광고 집행과 같이 특정 아이템이 많이 노출되어 클릭되는 경우</p>
</li>
<li>
<p>유저의 아이템에 대한 평점이 정확하지 않은 경우(implicit Feedback)</p>
</li>
<li>
<p><strong>기존 목적 함수</strong></p>
<p><code>$$ {\tt \min _{P, Q} \sum_{\text {observed } r_{u,i}}\left(r_{u, i}-\mu-b_u-b_i-p_u^T q_i\right)^2} \\+\tt\lambda\left(|| p_u\left\|_2^2+|| q_i\right\|_2^2+b_u^2+b_i^2\right) $$</code></p>
</li>
<li>
<p><strong>Confidence Level이 추가된 목적함수</strong></p>
<p><code>$$ {\tt \min _{P, Q} \sum_{\text {observed } r_{u, i}}  {c_{u, i}}\left(r_{u, i}-\mu-b_u-b_i-p_u^T q_i\right)^2}\\+\tt\lambda\left(|| p_u\left\|_2^2+|| q_i\right\|_2^2+b_u^2+b_i^2\right) $$</code></p>
</li>
</ul>
</li>
<li>
<h3 id="adding-temporal-dynamics">Adding Temporal Dynamics</h3>
<p>시간에 따라 변하는 유저, 아이템의 특성을 반영하고 싶다.</p>
<p>아이템이 시간이 지남에 따라 인기도가 떨어진다.</p>
<p>유저가 시간이 흐르면서 평점을 내리는 기준이 엄격해진다.</p>
<p>시간을 반영한 평점 예측</p>
<p>학습 파라미터가 시간을 반영하도록 모델 설계</p>
<p><code>$$ \tt \widehat r_{ui}(t) = \mu + b_u(t) + b_i(t) + p^T_uq_i(t) $$</code></p>
</li>
</ul>
<h2 id="단점">단점</h2>
<ul>
<li><strong>p, q 변수가 2개라서 빠른계산이 불가능하다.</strong>
<ul>
<li>SGD를 학습하는 과정에서 업데이트를 여러 번 하기 때문에
빠른 계산이 불가능하다는 단점이 누적된다.</li>
</ul>
</li>
<li>유저 수와 아이템 수가 커질수록 반복문으로 인한 연산량 증가</li>
</ul>
<!-- raw HTML omitted -->
<blockquote>
<p>여기서는 정답 횟수를 행렬의 값으로 사용하였지만 문제별로 사용한 시간의 평균 혹은 다른 feature를 값으로 활용한다면 다른 잠재 요인 값들을 얻어낼 수 있다.</p>
<ul>
<li><code>$R \approx PQ^{T}$</code>
<ul>
<li><code>$R$</code> : 유저들에 대한 문제별 정답 횟수 행렬</li>
<li><code>$P$</code> : 유저와 잠재 요인의 행렬</li>
<li><code>$Q$</code> : 문제와 잠재 요인의 행렬</li>
</ul>
</li>
</ul>
</blockquote>
<!-- raw HTML omitted -->
<p><strong>참고하면 좋은 자료</strong></p>
<ul>
<li><a href="https://medium.com/analytics-vidhya/understanding-of-matrix-factorization-mf-and-singular-value-decomposition-svd-1a38c2d5bbaa">Understanding of Matrix Factorization (MF) and Singular Value Decomposition (SVD) - Medium</a></li>
<li><a href="https://medium.com/swlh/latent-matrix-factorization-6fa1cd0b2e5f">Latent Matrix Factorization - Medium</a></li>
</ul>

        </p>
        
    </div>

    <div class="prev-next">
        
    </div>

    
    
    <svg id="btt-button" class="arrow-logo" xmlns="http://www.w3.org/2000/svg" height="1em" viewBox="0 0 384 512" onclick="topFunction()" title="Go to top">
        
        <path d="M177 159.7l136 136c9.4 9.4 9.4 24.6 0 33.9l-22.6 22.6c-9.4 9.4-24.6 9.4-33.9 0L160 255.9l-96.4 96.4c-9.4 9.4-24.6 9.4-33.9 0L7 329.7c-9.4-9.4-9.4-24.6 0-33.9l136-136c9.4-9.5 24.6-9.5 34-.1z"/>
    </svg>
    
    <script>
        let backToTopButton = document.getElementById("btt-button");

        window.onscroll = function() {
            scrollFunction()
        };

        function scrollFunction() {
            if (document.body.scrollTop > 20 || document.documentElement.scrollTop > 20) {
                backToTopButton.style.display = "block";
            } else {
                backToTopButton.style.display = "none";
            }
        }

        function topFunction() {
            smoothScrollToTop();
        }

        function smoothScrollToTop() {
            const scrollToTop = () => {
                const c = document.documentElement.scrollTop || document.body.scrollTop;
                if (c > 0) {
                    window.requestAnimationFrame(scrollToTop);
                    window.scrollTo(0, c - c / 8);
                }
            };
            scrollToTop();
        }
    </script>
    
    
    <div id="tex">
        <script type="text/javascript" async
  src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
  MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [['$','$'], ['\\(','\\)']],
    displayMath: [['$$','$$']],
    processEscapes: true,
    processEnvironments: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
    TeX: { equationNumbers: { autoNumber: "AMS" },
         extensions: ["AMSmath.js", "AMSsymbols.js"] }
  }
  });
  MathJax.Hub.Queue(function() {
    
    
    
    var all = MathJax.Hub.getAllJax(), i;
    for(i = 0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';
    }
  });
</script> 
    </div>
    
</div>

<aside class="post-toc">
    <nav id="toc">
        <nav id="TableOfContents">
  <ul>
    <li>
      <ul>
        <li><a href="#모델-학습-과정">모델 학습 과정</a></li>
        <li><a href="#objective-function">Objective Function</a>
          <ul>
            <li><a href="#기본-형태">기본 형태</a></li>
            <li><a href="#최종-형태">최종 형태</a></li>
            <li><a href="#mf-학습">MF 학습</a></li>
          </ul>
        </li>
        <li><a href="#mf-기반-추천으로-가장-널리-알려진-논문">MF 기반 추천으로 가장 널리 알려진 논문</a>
          <ul>
            <li><a href="#adding-biases">Adding Biases</a></li>
            <li><a href="#adding-confidence-level">Adding Confidence Level</a></li>
            <li><a href="#adding-temporal-dynamics">Adding Temporal Dynamics</a></li>
          </ul>
        </li>
        <li><a href="#단점">단점</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </nav>
</aside>


    

        </main><footer class="footer">
    
    

    
    <span>&copy; 2024 오뚝이 개발자</span>
    
</footer>
</body>
</html>
